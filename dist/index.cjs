#!/usr/bin/env node
"use strict";var T=Object.create;var x=Object.defineProperty;var U=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var O=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var $=(a,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of _(e))!q.call(a,r)&&r!==t&&x(a,r,{get:()=>e[r],enumerable:!(n=U(e,r))||n.enumerable});return a};var F=(a,e,t)=>(t=a!=null?T(O(a)):{},$(e||!a||!a.__esModule?x(t,"default",{value:a,enumerable:!0}):t,a));var D=require("@modelcontextprotocol/sdk/server/index.js"),R=require("@modelcontextprotocol/sdk/server/stdio.js"),m=require("@modelcontextprotocol/sdk/types.js");var b="0.1.5";var u=require("@modelcontextprotocol/sdk/types.js");var p=require("@modelcontextprotocol/sdk/types.js"),h=F(require("axios"),1),M=require("yanki-connect"),C=class extends Error{constructor(e){super(e),this.name="AnkiConnectionError"}},k=class extends Error{constructor(e){super(e),this.name="AnkiTimeoutError"}},N=class extends Error{constructor(t,n){super(t);this.code=n;this.name="AnkiApiError"}},l=class extends Error{constructor(e){super(e),this.name="PayloadConnectionError"}},d=class extends Error{constructor(t,n){super(t);this.statusCode=n;this.name="PayloadApiError"}},j={ankiConnectUrl:"http://localhost:8765",apiVersion:6,timeout:5e3,retryTimeout:1e4,defaultDeck:"Default"},g=class{constructor(e={}){this.config={...j,...e},this.client=new M.YankiConnect}async executeWithRetry(e,t=1){let n=null;for(let r=0;r<=t;r++)try{return await e()}catch(i){if(n=this.normalizeError(i),r<t){let s=Math.min(1e3*Math.pow(2,r),this.config.retryTimeout);await new Promise(c=>setTimeout(c,s))}}throw n||new C("Unknown error occurred")}normalizeError(e){return e instanceof Error?e.message.includes("ECONNREFUSED")?new C("Anki is not running. Please start Anki and ensure AnkiConnect plugin is enabled."):e.message.includes("timeout")||e.message.includes("ETIMEDOUT")?new k("Connection to Anki timed out. Please check if Anki is responsive."):e.message.includes("collection unavailable")?new N("Anki collection is unavailable. Please close any open dialogs in Anki."):e:new Error(String(e))}wrapError(e){return e instanceof C?new p.McpError(p.ErrorCode.InternalError,e.message):e instanceof k?new p.McpError(p.ErrorCode.InternalError,e.message):e instanceof N?new p.McpError(p.ErrorCode.InternalError,e.message):new p.McpError(p.ErrorCode.InternalError,`Anki error: ${e.message}`)}async checkConnection(){try{return await this.executeWithRetry(()=>this.client.invoke("version")),!0}catch(e){throw this.wrapError(e instanceof Error?e:new Error(String(e)))}}async getDeckNames(){try{return await this.executeWithRetry(()=>this.client.deck.deckNames())}catch(e){throw this.wrapError(e instanceof Error?e:new Error(String(e)))}}async createDeck(e){try{let t=await this.executeWithRetry(()=>this.client.deck.createDeck({deck:e}));return typeof t=="number"?t:0}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async getModelNames(){try{return await this.executeWithRetry(()=>this.client.model.modelNames())}catch(e){throw this.wrapError(e instanceof Error?e:new Error(String(e)))}}async getModelFieldNames(e){try{return await this.executeWithRetry(()=>this.client.model.modelFieldNames({modelName:e}))}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async getModelTemplates(e){try{return await this.executeWithRetry(()=>this.client.model.modelTemplates({modelName:e}))}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async getModelStyling(e){try{return await this.executeWithRetry(()=>this.client.model.modelStyling({modelName:e}))}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async addNote(e){try{return await this.executeWithRetry(()=>{var t;return this.client.note.addNote({note:{deckName:e.deckName,modelName:e.modelName,fields:e.fields,tags:e.tags||[],options:{allowDuplicate:((t=e.options)==null?void 0:t.allowDuplicate)||!1,duplicateScope:"deck"}}})})}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async addNotes(e){try{return await this.executeWithRetry(()=>this.client.note.addNotes({notes:e.map(t=>({deckName:t.deckName,modelName:t.modelName,fields:t.fields,tags:t.tags||[],options:{allowDuplicate:!1,duplicateScope:"deck"}}))}))}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async findNotes(e){try{let t=await this.executeWithRetry(()=>this.client.note.findNotes({query:e}));return Array.isArray(t)?t.filter(n=>typeof n=="number"):[]}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async notesInfo(e){try{let t=await this.executeWithRetry(()=>this.client.note.notesInfo({notes:e}));return Array.isArray(t)?t:[]}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async updateNoteFields(e){try{await this.executeWithRetry(()=>this.client.note.updateNoteFields({note:{id:e.id,fields:e.fields}}))}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async deleteNotes(e){try{await this.executeWithRetry(()=>this.client.note.deleteNotes({notes:e}))}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}async createModel(e){try{let t=e.cardTemplates.map(n=>({name:n.name,Front:n.front,Back:n.back}));await this.executeWithRetry(()=>this.client.model.createModel({modelName:e.modelName,inOrderFields:e.inOrderFields,css:e.css,cardTemplates:t}))}catch(t){throw this.wrapError(t instanceof Error?t:new Error(String(t)))}}},S=class{constructor(){this.httpClient=h.default.create({timeout:1e4,headers:{"Content-Type":"application/json",Accept:"application/json"}})}async createAtom(e,t){var n;try{let r=`${e.replace(/\/$/,"")}/api/atoms`,i=await this.httpClient.post(r,t),s=i.data;if(typeof s=="string")try{s=JSON.parse(s)}catch{throw new d(`Payload returned non-JSON response: ${s.substring(0,200)}...`,i.status)}let c=s.doc||s;if(!c||!c.id)throw new d(`Invalid response from Payload CMS: missing id field. Actual response: ${JSON.stringify(s)}`,i.status);return{id:c.id}}catch(r){if(r instanceof h.AxiosError){if(r.code==="ECONNREFUSED"||r.code==="ENOTFOUND")throw new l(`Cannot connect to Payload CMS at ${e}. Please check the URL and ensure the server is running.`);if(r.response){let i=r.response.status,s=((n=r.response.data)==null?void 0:n.message)||r.message;throw new d(`Payload CMS API error: ${s}`,i)}throw new l(`Network error connecting to Payload CMS: ${r.message}`)}throw r}}async getAtom(e,t){var n;try{let r=`${e.replace(/\/$/,"")}/api/atoms/${t}`,i=await this.httpClient.get(r);if(!i.data)throw new d("Invalid response from Payload CMS: no data",i.status);return i.data}catch(r){if(r instanceof h.AxiosError){if(r.code==="ECONNREFUSED"||r.code==="ENOTFOUND")throw new l(`Cannot connect to Payload CMS at ${e}. Please check the URL and ensure the server is running.`);if(r.response){let i=r.response.status,s=((n=r.response.data)==null?void 0:n.message)||r.message;throw new d(`Payload CMS API error: ${s}`,i)}throw new l(`Network error connecting to Payload CMS: ${r.message}`)}throw r}}async listAtoms(e,t){var n;try{let r=`${e.replace(/\/$/,"")}/api/atoms`,i=new URLSearchParams;return t!=null&&t.limit&&i.append("limit",t.limit.toString()),t!=null&&t.page&&i.append("page",t.page.toString()),t!=null&&t.where&&i.append("where",JSON.stringify(t.where)),(await this.httpClient.get(`${r}?${i.toString()}`)).data}catch(r){if(r instanceof h.AxiosError){if(r.code==="ECONNREFUSED"||r.code==="ENOTFOUND")throw new l(`Cannot connect to Payload CMS at ${e}. Please check the URL and ensure the server is running.`);if(r.response){let i=r.response.status,s=((n=r.response.data)==null?void 0:n.message)||r.message;throw new d(`Payload CMS API error: ${s}`,i)}throw new l(`Network error connecting to Payload CMS: ${r.message}`)}throw r}}async updateAtom(e,t,n){var r;try{let i=`${e.replace(/\/$/,"")}/api/atoms/${t}`,s=await this.httpClient.patch(i,n);if(!s.data)throw new d("Invalid response from Payload CMS: no data",s.status);return s.data}catch(i){if(i instanceof h.AxiosError){if(i.code==="ECONNREFUSED"||i.code==="ENOTFOUND")throw new l(`Cannot connect to Payload CMS at ${e}. Please check the URL and ensure the server is running.`);if(i.response){let s=i.response.status,c=((r=i.response.data)==null?void 0:r.message)||i.message;throw new d(`Payload CMS API error: ${c}`,s)}throw new l(`Network error connecting to Payload CMS: ${i.message}`)}throw i}}async deleteAtom(e,t){var n;try{let r=`${e.replace(/\/$/,"")}/api/atoms/${t}`;await this.httpClient.delete(r)}catch(r){if(r instanceof h.AxiosError){if(r.code==="ECONNREFUSED"||r.code==="ENOTFOUND")throw new l(`Cannot connect to Payload CMS at ${e}. Please check the URL and ensure the server is running.`);if(r.response){let i=r.response.status,s=((n=r.response.data)==null?void 0:n.message)||r.message;throw new d(`Payload CMS API error: ${s}`,i)}throw new l(`Network error connecting to Payload CMS: ${r.message}`)}throw r}}async createLecture(e,t){var n;try{let r=`${e.replace(/\/$/,"")}/api/lectures`,i=await this.httpClient.post(r,t),s=i.data;if(typeof s=="string")try{s=JSON.parse(s)}catch{throw new d(`Payload returned non-JSON response: ${s.substring(0,200)}...`,i.status)}let c=s.doc||s;if(!c||!c.id)throw new d(`Invalid response from Payload CMS: missing id field. Actual response: ${JSON.stringify(s)}`,i.status);return{id:c.id}}catch(r){if(r instanceof h.AxiosError){if(r.code==="ECONNREFUSED"||r.code==="ENOTFOUND")throw new l(`Cannot connect to Payload CMS at ${e}. Please check the URL and ensure the server is running.`);if(r.response){let i=r.response.status,s=((n=r.response.data)==null?void 0:n.message)||r.message;throw new d(`Payload CMS API error: ${s}`,i)}throw new l(`Network error connecting to Payload CMS: ${r.message}`)}throw r}}async getLecture(e,t){var n;try{let r=`${e.replace(/\/$/,"")}/api/lectures/${t}`,i=await this.httpClient.get(r);if(!i.data)throw new d("Invalid response from Payload CMS: no data",i.status);return i.data}catch(r){if(r instanceof h.AxiosError){if(r.code==="ECONNREFUSED"||r.code==="ENOTFOUND")throw new l(`Cannot connect to Payload CMS at ${e}. Please check the URL and ensure the server is running.`);if(r.response){let i=r.response.status,s=((n=r.response.data)==null?void 0:n.message)||r.message;throw new d(`Payload CMS API error: ${s}`,i)}throw new l(`Network error connecting to Payload CMS: ${r.message}`)}throw r}}wrapError(e){return e instanceof l?new p.McpError(p.ErrorCode.InternalError,e.message):e instanceof d?new p.McpError(p.ErrorCode.InternalError,e.message):new p.McpError(p.ErrorCode.InternalError,`Payload error: ${e.message}`)}};var P=class{constructor(){this.ankiClient=new g,this.modelSchemaCache=new Map,this.allModelSchemasCache=null,this.cacheExpiry=5*60*1e3,this.lastCacheUpdate=0}async listResources(){return await this.ankiClient.checkConnection(),{resources:[{uri:"anki://decks/all",name:"All Decks",description:"List of all available decks in Anki",mimeType:"application/json"}]}}async listResourceTemplates(){return await this.ankiClient.checkConnection(),{resourceTemplates:[{uriTemplate:"anki://note-types/{modelName}",name:"Note Type Schema",description:"Detailed structure information for a specific note type",mimeType:"application/json"},{uriTemplate:"anki://note-types/all",name:"All Note Types",description:"List of all available note types",mimeType:"application/json"},{uriTemplate:"anki://note-types/all-with-schemas",name:"All Note Types with Schemas",description:"Detailed structure information for all note types",mimeType:"application/json"},{uriTemplate:"anki://decks/all",name:"All Decks",description:"Complete list of available decks",mimeType:"application/json"}]}}async readResource(e){if(await this.ankiClient.checkConnection(),e==="anki://decks/all"){let n=await this.ankiClient.getDeckNames();return{contents:[{uri:e,mimeType:"application/json",text:JSON.stringify({decks:n,count:n.length},null,2)}]}}if(e==="anki://note-types/all"){let n=await this.ankiClient.getModelNames();return{contents:[{uri:e,mimeType:"application/json",text:JSON.stringify({noteTypes:n,count:n.length},null,2)}]}}if(e==="anki://note-types/all-with-schemas"){let n=await this.getAllModelSchemas();return{contents:[{uri:e,mimeType:"application/json",text:JSON.stringify({noteTypes:n,count:n.length},null,2)}]}}let t=e.match(/^anki:\/\/note-types\/(.+)$/);if(t){let n=decodeURIComponent(t[1]);try{let r=await this.getModelSchema(n);return{contents:[{uri:e,mimeType:"application/json",text:JSON.stringify({modelName:r.modelName,fields:r.fields,templates:r.templates,css:r.css,createTool:`create_${n.replace(/\s+/g,"_")}_note`},null,2)}]}}catch{throw new u.McpError(u.ErrorCode.InvalidParams,`Note type '${n}' does not exist`)}}throw new u.McpError(u.ErrorCode.InvalidParams,`Unknown resource: ${e}`)}async getModelSchema(e){if(!e)throw new u.McpError(u.ErrorCode.InvalidParams,"Model name is required");let t=Date.now(),n=this.modelSchemaCache.get(e);if(n&&t-this.lastCacheUpdate<this.cacheExpiry)return n;if(!(await this.ankiClient.getModelNames()).includes(e))throw new u.McpError(u.ErrorCode.InvalidParams,`Note type not found: ${e}`);let[i,s,c]=await Promise.all([this.ankiClient.getModelFieldNames(e),this.ankiClient.getModelTemplates(e),this.ankiClient.getModelStyling(e)]),y={modelName:e,fields:i,templates:s,css:c.css};return this.modelSchemaCache.set(e,y),this.lastCacheUpdate=t,y}async getAllModelSchemas(){let e=Date.now();if(this.allModelSchemasCache&&e-this.lastCacheUpdate<this.cacheExpiry)return this.allModelSchemasCache;let t=await this.ankiClient.getModelNames(),n=await Promise.all(t.map(r=>this.getModelSchema(r)));return this.allModelSchemasCache=n,this.lastCacheUpdate=e,n}clearCache(){this.modelSchemaCache.clear(),this.allModelSchemasCache=null,this.lastCacheUpdate=0}};var o=require("@modelcontextprotocol/sdk/types.js");var E=class{constructor(){this.ankiClient=new g,this.payloadClient=new S}async getToolSchema(){return{tools:[{name:"list_decks",description:"List all available Anki decks",inputSchema:{type:"object",properties:{},required:[]}},{name:"create_deck",description:"Create a new Anki deck",inputSchema:{type:"object",properties:{name:{type:"string",description:"Name of the deck to create"}},required:["name"]}},{name:"get_note_type_info",description:"Get detailed structure of a note type",inputSchema:{type:"object",properties:{modelName:{type:"string",description:"Name of the note type/model"},includeCss:{type:"boolean",description:"Whether to include CSS information"}},required:["modelName"]}},{name:"create_note",description:"Create a new note (LLM Should call get_note_type_info first)",inputSchema:{type:"object",properties:{type:{type:"string",description:"Note type"},deck:{type:"string",description:"Deck name"},fields:{type:"object",description:"Custom fields for the note(get note type info first)",additionalProperties:!0},allowDuplicate:{type:"boolean",description:"Whether to allow duplicate notes"},tags:{type:"array",items:{type:"string"},description:"Tags for the note"}},required:["type","deck","fields"]}},{name:"batch_create_notes",description:"Create multiple notes at once (llm should call get_note_type_info first )",inputSchema:{type:"object",properties:{notes:{type:"array",items:{type:"object",properties:{type:{type:"string",enum:["Basic","Cloze"]},deck:{type:"string"},fields:{type:"object",additionalProperties:!0},tags:{type:"array",items:{type:"string"}}},required:["type","deck","fields"]}},allowDuplicate:{type:"boolean",description:"Whether to allow duplicate notes"},stopOnError:{type:"boolean",description:"Whether to stop on first error"}},required:["notes"]}},{name:"search_notes",description:"Search for notes using Anki query syntax",inputSchema:{type:"object",properties:{query:{type:"string",description:"Anki search query"}},required:["query"]}},{name:"get_note_info",description:"Get detailed information about a note",inputSchema:{type:"object",properties:{noteId:{type:"number",description:"Note ID"}},required:["noteId"]}},{name:"update_note",description:"Update an existing note",inputSchema:{type:"object",properties:{id:{type:"number",description:"Note ID"},fields:{type:"object",description:"Fields to update"},tags:{type:"array",items:{type:"string"},description:"New tags for the note"}},required:["id","fields"]}},{name:"delete_note",description:"Delete a note",inputSchema:{type:"object",properties:{noteId:{type:"number",description:"Note ID to delete"}},required:["noteId"]}},{name:"list_note_types",description:"List all available note types",inputSchema:{type:"object",properties:{},required:[]}},{name:"create_note_type",description:"Create a new note type",inputSchema:{type:"object",properties:{name:{type:"string",description:"Name of the new note type"},fields:{type:"array",items:{type:"string"},description:"Field names for the note type"},css:{type:"string",description:"CSS styling for the note type"},templates:{type:"array",items:{type:"object",properties:{name:{type:"string"},front:{type:"string"},back:{type:"string"}},required:["name","front","back"]},description:"Card templates"}},required:["name","fields","templates"]}},{name:"create_atom",description:"Create a new atom document in Payload CMS",inputSchema:{type:"object",properties:{payloadUrl:{type:"string",description:"Base URL of the Payload CMS instance (defaults to http://localhost:3000)"},atomData:{type:"object",description:"Data for the atom document",additionalProperties:!0}},required:["atomData"]}},{name:"get_atom",description:"Get an atom document from Payload CMS by ID",inputSchema:{type:"object",properties:{payloadUrl:{type:"string",description:"Base URL of the Payload CMS instance (defaults to http://localhost:3000)"},atomId:{type:"string",description:"ID of the atom document to retrieve"}},required:["atomId"]}},{name:"list_atoms",description:"List atoms from Payload CMS with optional filtering and pagination",inputSchema:{type:"object",properties:{payloadUrl:{type:"string",description:"Base URL of the Payload CMS instance (defaults to http://localhost:3000)"},limit:{type:"number",description:"Number of atoms to return per page (default: 10)"},page:{type:"number",description:"Page number to retrieve (default: 1)"},where:{type:"object",description:"Filter conditions for the atoms query",additionalProperties:!0}},required:[]}},{name:"update_atom",description:"Update an existing atom document in Payload CMS",inputSchema:{type:"object",properties:{payloadUrl:{type:"string",description:"Base URL of the Payload CMS instance (defaults to http://localhost:3000)"},atomId:{type:"string",description:"ID of the atom document to update"},atomData:{type:"object",description:"Updated data for the atom document",additionalProperties:!0}},required:["atomId","atomData"]}},{name:"delete_atom",description:"Delete an atom document from Payload CMS",inputSchema:{type:"object",properties:{payloadUrl:{type:"string",description:"Base URL of the Payload CMS instance (defaults to http://localhost:3000)"},atomId:{type:"string",description:"ID of the atom document to delete"}},required:["atomId"]}},{name:"create_lecture",description:"Create a new lecture document in Payload CMS",inputSchema:{type:"object",properties:{payloadUrl:{type:"string",description:"Base URL of the Payload CMS instance (defaults to http://localhost:3000)"},lectureData:{type:"object",description:"Data for the lecture document",additionalProperties:!0}},required:["lectureData"]}},{name:"get_lecture",description:"Get a lecture document from Payload CMS by ID",inputSchema:{type:"object",properties:{payloadUrl:{type:"string",description:"Base URL of the Payload CMS instance (defaults to http://localhost:3000)"},lectureId:{type:"string",description:"ID of the lecture document to retrieve"}},required:["lectureId"]}}]}}async createAtom(e){if(!e.atomData||typeof e.atomData!="object")throw new o.McpError(o.ErrorCode.InvalidParams,"Atom data is required");let t=e.payloadUrl||"http://localhost:3000";try{let n=await this.payloadClient.createAtom(t,e.atomData);return{content:[{type:"text",text:JSON.stringify({success:!0,message:"Atom successfully created",atomId:n.id,payloadUrl:t,atomData:e.atomData},null,2)}]}}catch(n){throw this.payloadClient.wrapError(n instanceof Error?n:new Error(String(n)))}}async getAtom(e){if(!e.atomId)throw new o.McpError(o.ErrorCode.InvalidParams,"Atom ID is required");let t=e.payloadUrl||"http://localhost:3000";try{let n=await this.payloadClient.getAtom(t,e.atomId);return{content:[{type:"text",text:JSON.stringify(n,null,2)}]}}catch(n){throw this.payloadClient.wrapError(n instanceof Error?n:new Error(String(n)))}}async listAtoms(e){let t=e.payloadUrl||"http://localhost:3000";try{let n=await this.payloadClient.listAtoms(t,{limit:e.limit,page:e.page,where:e.where});return{content:[{type:"text",text:JSON.stringify(n,null,2)}]}}catch(n){throw this.payloadClient.wrapError(n instanceof Error?n:new Error(String(n)))}}async updateAtom(e){if(!e.atomId)throw new o.McpError(o.ErrorCode.InvalidParams,"Atom ID is required");if(!e.atomData||typeof e.atomData!="object")throw new o.McpError(o.ErrorCode.InvalidParams,"Atom data is required");let t=e.payloadUrl||"http://localhost:3000";try{let n=await this.payloadClient.updateAtom(t,e.atomId,e.atomData);return{content:[{type:"text",text:JSON.stringify({success:!0,message:"Atom successfully updated",atomId:e.atomId,updatedData:n},null,2)}]}}catch(n){throw this.payloadClient.wrapError(n instanceof Error?n:new Error(String(n)))}}async deleteAtom(e){if(!e.atomId)throw new o.McpError(o.ErrorCode.InvalidParams,"Atom ID is required");let t=e.payloadUrl||"http://localhost:3000";try{return await this.payloadClient.deleteAtom(t,e.atomId),{content:[{type:"text",text:JSON.stringify({success:!0,message:"Atom successfully deleted",atomId:e.atomId},null,2)}]}}catch(n){throw this.payloadClient.wrapError(n instanceof Error?n:new Error(String(n)))}}async createLecture(e){if(!e.lectureData||typeof e.lectureData!="object")throw new o.McpError(o.ErrorCode.InvalidParams,"Lecture data is required");let t=e.payloadUrl||"http://localhost:3000";try{let n=await this.payloadClient.createLecture(t,e.lectureData);return{content:[{type:"text",text:JSON.stringify({success:!0,message:"Lecture successfully created",lectureId:n.id,payloadUrl:t,lectureData:e.lectureData},null,2)}]}}catch(n){throw this.payloadClient.wrapError(n instanceof Error?n:new Error(String(n)))}}async getLecture(e){if(!e.lectureId)throw new o.McpError(o.ErrorCode.InvalidParams,"Lecture ID is required");let t=e.payloadUrl||"http://localhost:3000";try{let n=await this.payloadClient.getLecture(t,e.lectureId);return{content:[{type:"text",text:JSON.stringify(n,null,2)}]}}catch(n){throw this.payloadClient.wrapError(n instanceof Error?n:new Error(String(n)))}}async executeTool(e,t){["create_atom","get_atom","list_atoms","update_atom","delete_atom","create_lecture","get_lecture"].includes(e)||await this.ankiClient.checkConnection();try{switch(e){case"list_decks":return this.listDecks();case"create_deck":return this.createDeck(t);case"list_note_types":return this.listNoteTypes();case"create_note_type":return this.createNoteType(t);case"get_note_type_info":return this.getNoteTypeInfo(t);case"create_note":return this.createNote(t);case"batch_create_notes":return this.batchCreateNotes(t);case"search_notes":return this.searchNotes(t);case"get_note_info":return this.getNoteInfo(t);case"update_note":return this.updateNote(t);case"delete_note":return this.deleteNote(t);case"create_atom":return this.createAtom(t);case"get_atom":return this.getAtom(t);case"list_atoms":return this.listAtoms(t);case"update_atom":return this.updateAtom(t);case"delete_atom":return this.deleteAtom(t);case"create_lecture":return this.createLecture(t);case"get_lecture":return this.getLecture(t);default:let r=e.match(/^create_(.+)_note$/);if(r){let i=r[1].replace(/_/g," ");return this.createModelSpecificNote(i,t)}throw new o.McpError(o.ErrorCode.MethodNotFound,`Unknown tool: ${e}`)}}catch(r){if(r instanceof o.McpError)throw r;return{content:[{type:"text",text:`Error: ${r instanceof Error?r.message:String(r)}`}],isError:!0}}}async listDecks(){let e=await this.ankiClient.getDeckNames();return{content:[{type:"text",text:JSON.stringify({decks:e,count:e.length},null,2)}]}}async createDeck(e){if(!e.name)throw new o.McpError(o.ErrorCode.InvalidParams,"Deck name is required");let t=await this.ankiClient.createDeck(e.name);return{content:[{type:"text",text:JSON.stringify({deckId:t,name:e.name},null,2)}]}}async listNoteTypes(){let e=await this.ankiClient.getModelNames();return{content:[{type:"text",text:JSON.stringify({noteTypes:e,count:e.length},null,2)}]}}async createNoteType(e){if(!e.name)throw new o.McpError(o.ErrorCode.InvalidParams,"Note type name is required");if(!e.fields||e.fields.length===0)throw new o.McpError(o.ErrorCode.InvalidParams,"Fields are required");if(!e.templates||e.templates.length===0)throw new o.McpError(o.ErrorCode.InvalidParams,"Templates are required");if((await this.ankiClient.getModelNames()).includes(e.name))throw new o.McpError(o.ErrorCode.InvalidParams,`Note type already exists: ${e.name}`);return await this.ankiClient.createModel({modelName:e.name,inOrderFields:e.fields,css:e.css||"",cardTemplates:e.templates}),{content:[{type:"text",text:JSON.stringify({success:!0,modelName:e.name,fields:e.fields,templates:e.templates.length},null,2)}]}}async getNoteTypeInfo(e){if(!e.modelName)throw new o.McpError(o.ErrorCode.InvalidParams,"Model name is required");if(!(await this.ankiClient.getModelNames()).includes(e.modelName))throw new o.McpError(o.ErrorCode.InvalidParams,`Note type not found: ${e.modelName}`);let[n,r]=await Promise.all([this.ankiClient.getModelFieldNames(e.modelName),this.ankiClient.getModelTemplates(e.modelName)]),i={modelName:e.modelName,fields:n,templates:r};if(e.includeCss){let s=await this.ankiClient.getModelStyling(e.modelName);i.css=s.css}return{content:[{type:"text",text:JSON.stringify(i,null,2)}]}}async createNote(e){if(!e.type)throw new o.McpError(o.ErrorCode.InvalidParams,"Note type is required");if(!e.deck)throw new o.McpError(o.ErrorCode.InvalidParams,"Deck name is required");if(!e.fields||Object.keys(e.fields).length===0)throw new o.McpError(o.ErrorCode.InvalidParams,"Fields are required");if((await this.ankiClient.getDeckNames()).includes(e.deck)||await this.ankiClient.createDeck(e.deck),!(await this.ankiClient.getModelNames()).includes(e.type))throw new o.McpError(o.ErrorCode.InvalidParams,`Note type not found: ${e.type}`);let r=await this.ankiClient.getModelFieldNames(e.type),i={};for(let c of r)i[c]=e.fields[c]||e.fields[c.toLowerCase()]||"";let s=await this.ankiClient.addNote({deckName:e.deck,modelName:e.type,fields:i,tags:e.tags||[],options:{allowDuplicate:e.allowDuplicate||!1}});return{content:[{type:"text",text:JSON.stringify({noteId:s,deck:e.deck,modelName:e.type},null,2)}]}}async createModelSpecificNote(e,t){if(!t.deck)throw new o.McpError(o.ErrorCode.InvalidParams,"Deck name is required");if(!(await this.ankiClient.getModelNames()).includes(e))throw new o.McpError(o.ErrorCode.InvalidParams,`Note type not found: ${e}`);(await this.ankiClient.getDeckNames()).includes(t.deck)||await this.ankiClient.createDeck(t.deck);let i=await this.ankiClient.getModelFieldNames(e),s={};for(let f of i)s[f]=t[f.toLowerCase()]||t[f]||"";let c=Array.isArray(t.tags)?t.tags:[],y=await this.ankiClient.addNote({deckName:t.deck,modelName:e,fields:s,tags:c});return{content:[{type:"text",text:JSON.stringify({noteId:y,deck:t.deck,modelName:e},null,2)}]}}async batchCreateNotes(e){if(!e.notes||!Array.isArray(e.notes)||e.notes.length===0)throw new o.McpError(o.ErrorCode.InvalidParams,"Notes array is required");let t=[],n=e.stopOnError!==!1;for(let r=0;r<e.notes.length;r++){let i=e.notes[r];try{if((await this.ankiClient.getDeckNames()).includes(i.deck)||await this.ankiClient.createDeck(i.deck),!(await this.ankiClient.getModelNames()).includes(i.type))throw new Error(`Note type not found: ${i.type}`);let y=await this.ankiClient.getModelFieldNames(i.type),f={};for(let v of y)f[v]=i.fields[v]||i.fields[v.toLowerCase()]||"";let A=await this.ankiClient.addNote({deckName:i.deck,modelName:i.type,fields:f,tags:i.tags||[],options:{allowDuplicate:e.allowDuplicate||!1}});t.push({success:!0,noteId:A,index:r})}catch(s){if(t.push({success:!1,error:s instanceof Error?s.message:String(s),index:r}),n)break}}return{content:[{type:"text",text:JSON.stringify({results:t,total:e.notes.length,successful:t.filter(r=>r.success).length,failed:t.filter(r=>!r.success).length},null,2)}]}}async searchNotes(e){if(!e.query)throw new o.McpError(o.ErrorCode.InvalidParams,"Search query is required");let t=await this.ankiClient.findNotes(e.query),n=[];if(t.length>0){let r=Math.min(t.length,50);n=await this.ankiClient.notesInfo(t.slice(0,r))}return{content:[{type:"text",text:JSON.stringify({query:e.query,total:t.length,notes:n,limitApplied:t.length>50},null,2)}]}}async getNoteInfo(e){if(!e.noteId)throw new o.McpError(o.ErrorCode.InvalidParams,"Note ID is required");let t=await this.ankiClient.notesInfo([e.noteId]);if(!t||t.length===0)throw new o.McpError(o.ErrorCode.InvalidParams,`Note not found: ${e.noteId}`);return{content:[{type:"text",text:JSON.stringify(t[0],null,2)}]}}async updateNote(e){if(!e.id)throw new o.McpError(o.ErrorCode.InvalidParams,"Note ID is required");if(!e.fields||Object.keys(e.fields).length===0)throw new o.McpError(o.ErrorCode.InvalidParams,"Fields are required");let t=await this.ankiClient.notesInfo([e.id]);if(!t||t.length===0)throw new o.McpError(o.ErrorCode.InvalidParams,`Note not found: ${e.id}`);return await this.ankiClient.updateNoteFields({id:e.id,fields:e.fields}),{content:[{type:"text",text:JSON.stringify({success:!0,noteId:e.id},null,2)}]}}async deleteNote(e){if(!e.noteId)throw new o.McpError(o.ErrorCode.InvalidParams,"Note ID is required");return await this.ankiClient.deleteNotes([e.noteId]),{content:[{type:"text",text:JSON.stringify({success:!0,noteId:e.noteId},null,2)}]}}};var I=class{constructor(){this.server=new D.Server({name:"anki-connect-server",version:b},{capabilities:{tools:{},resources:{}}}),this.ankiClient=new g,this.resourceHandler=new P,this.toolHandler=new E,this.setupHandlers(),this.server.onerror=e=>console.error("[MCP Error]",e),process.on("SIGINT",async()=>{await this.server.close(),process.exit(0)})}setupHandlers(){this.server.setRequestHandler(m.ListResourcesRequestSchema,async()=>(await this.checkConnection(),this.resourceHandler.listResources())),this.server.setRequestHandler(m.ListResourceTemplatesRequestSchema,async()=>(await this.checkConnection(),this.resourceHandler.listResourceTemplates())),this.server.setRequestHandler(m.ReadResourceRequestSchema,async e=>(await this.checkConnection(),this.resourceHandler.readResource(e.params.uri))),this.server.setRequestHandler(m.ListToolsRequestSchema,async()=>(await this.checkConnection(),this.toolHandler.getToolSchema())),this.server.setRequestHandler(m.CallToolRequestSchema,async e=>(await this.checkConnection(),this.toolHandler.executeTool(e.params.name,e.params.arguments)))}async checkConnection(){try{await this.ankiClient.checkConnection()}catch{throw new m.McpError(m.ErrorCode.InternalError,"Failed to connect to Anki. Please make sure Anki is running and the AnkiConnect plugin is enabled.")}}async run(){let e=new R.StdioServerTransport;await this.server.connect(e),console.error("Anki MCP server running on stdio")}};async function L(){try{await new I().run()}catch(a){console.error("Failed to start Anki MCP Server:",a),process.exit(1)}}L().catch(console.error);
